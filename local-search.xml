<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CKAD 考試心得</title>
    <link href="/2025-10-03/ckad-preparation/"/>
    <url>/2025-10-03/ckad-preparation/</url>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-evenly">  <div style="padding: 5px; width: 80%">    <img src="/2025-10-03/ckad-preparation/image-0.png" class="">  </div></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先不要問我考這個可以幹嘛，有證照在求職或面試上真的幫助不大。雖然這麼說但去年還是報考了，一方面是想用＄督促自己唸書；另一方面聽說 CKAD、CKA 等考試方式是上機考，感覺是個不錯的體驗想試試看，<del>畢竟有張證照在公司講話也比較大聲（吧）</del>。</p><p>拖拖拉拉準備半年終於考過了，附上人權</p><div style="display: flex; justify-content: space-evenly">  <div style="padding: 5px; width: 80%">    <img src="/2025-10-03/ckad-preparation/image-1.png" class="">  </div></div><h2 id="準備過程"><a href="#準備過程" class="headerlink" title="準備過程"></a>準備過程</h2><p>這邊列出準備考試有用到的資源：</p><ol><li><a href="https://kubernetes.io/">Kubernetes 官方文件</a> - 常見的 resource 務必查到滾瓜爛熟</li><li><a href="https://www.udemy.com/course/certified-kubernetes-application-developer/">Udemy 課程</a> - 附 KodeKloud Lab 可以大量練習</li><li><a href="https://github.com/dgkanatsios/CKAD-exercises">CKAD exercise</a> - 題目很多，個人認為滿有幫助的</li><li><a href="https://killercoda.com/killer-shell-ckad">Killercoda</a> - Scenario 推薦都做過一遍</li><li>報名考試送的兩次模擬考</li></ol><p>準備上就以 Udemy 課程為主，考前大量做題練手感。這個課程非常推薦，雖然講師是印度人，但沒有什麼口音，每一章節後面都會附上 Lab 來練習，可以說是買 Lab 送課程，用優惠券買相當划算。</p><p>課程上完對常見的 resource 有了解後就開始大量做題。考試範圍其實有包含 Helm、docker &#x2F; podman、Kustomize，但我考兩次只有考過 docker，Helm 和 Kustomize 一題都沒出現。</p><p>做 CKAD exercise (Github repo 那個) 練習時，我是搭配免費的 K8s playground 如 Killercoda、Killershell 或是 KodeKloud 來練習，如果自己電腦有裝 Kind 也是可以用來練習，用這些雲端服務的好處就是用完不用自己去 reset 環境。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>看其他大神們如 Mike、Tico 的分享，考試好像很簡單（？），實際上並不是這樣，像我這種工作上只有接觸到皮毛的普通人，還是需要花時間練習。</p><p>上完課程其實不難，難的是每天下班累得要死，在送小孩上床後還要有意志力停住想點開遊戲的那根食指，打開課程和印度人共度美好的夜晚。</p><p>第一次考試以差兩分及格飲恨，一部分可以歸咎於考前遇到太多狀況而緊張，另一部分是很多東西都只有一知半解，雖然可以靠 YAML 或是 CLI 快速建立資源，但是要除錯還是得靠對 K8s 的理解。</p><p>有一說法是報名考試附的模擬考比實際考試難，個人體感差不多，只是模擬考題目多了點（約 22 題），實際考試我第一次 20 題、第二次 17 題。考試時間兩小時，如果手速比較慢的話會有時間上的壓力。</p><p>第二次寫完只有一題 ingress 相關的不確定，其他都有寫出來，最後成績是 91 分，有點出乎意料。</p><h2 id="考試建議"><a href="#考試建議" class="headerlink" title="考試建議"></a>考試建議</h2><ol><li>考前會需要排隊進去等待考官檢查你的環境，如果是在家考試，請把房間收得超級乾淨，伸手可及的地方都不要有考試不允許出現的物品。</li><li>準備夠大的螢幕，考試的畫面左方是題目，右邊是一台 Linux VM，那個畫面很小。因為是遠端連線，要有心理準備打字的延遲會跟不上你的手速，操作起來有點痛苦。</li><li>如果不是用筆電的話，攝影機的線一定要夠長，考官會要求拿攝影機拍你的桌子下方。我第一次考試因為這樣拉扯結果造成 webcam 斷線，一旦攝影機斷線你就會被踢出考試系統，從排隊開始的所有流程都要重來一遍。</li><li>實際考試有很多題目是模擬考和 KodeKloud 剛好沒有 cover 到的，因此還是推薦上面有列出的資源都務必練習過。</li><li>前一天一定要睡飽，考試會指定 ssh 到特定機器或是在特定的 namespace 下操作，題目一定要看清楚，不然一串帥氣操作結果 namespace 設成 default 可是一分都沒有。</li><li>準備時務必理解每一個 key 代表的意義。KodeKloud 的 Lab 會很好心的告訴你 key &#x2F; value 填什麼只要無腦複製貼上就好，但考試會像這樣考： <code>請建立一個 Cronjob 叫 grep 使用 XXXX 指令，每 30 分鐘執行一次，失敗不重啟 Pod，保留 196 個成功的 Job 以及 87 個失敗的 Job，每個 Job 執行時間不能超過 8 秒</code>。 看到這個要馬上知道在文件中要搜尋這些關鍵字： <code>successfulJobsHistoryLimit</code>、<code>failedJobsHistoryLimit</code> 、<code>activeDeadlineSeconds</code> 等等。</li><li>能夠用 CLI 一行指令操作的都用 CLI 做，不要去複製 YAML，這樣會太慢。例如建立 Pod 就用 <code>k run tmp --image=busybox</code>。</li><li>不熟 Vim 的人需要練習一下，像是編輯、退出、複製、插入、縮排這些指令熟悉可以省下很多時間。</li><li>在大量練習的過程也要練習怎麼快速驗證操作是正確的，不要想說全部做完再回頭檢查，做完下一些 <code>get</code> <code>describe</code> 檢查不會花太多時間。如果是要測網路，可以用 <code>k run tmp --image=busybox --rm -it --restart=Never -- wget -O- &lt;url&gt;</code> 來快速測試。印象中有一題是要修改一個 deployment，改完發現怎麼 Pod 沒有被更新，查了一下才發現原來是 rollout 被暫停了，如果沒檢查到這題就做白工了。</li></ol><p>其他有想到的之後再補充吧</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CKAD</tag>
      
      <tag>Kubernetes</tag>
      
      <tag>K8s</tag>
      
      <tag>Certification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Roo Code 上試玩 MCP server</title>
    <link href="/2025-08-29/play-mcp-with-roo-code/"/>
    <url>/2025-08-29/play-mcp-with-roo-code/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司最近吹起一股像是尋找大秘寶的風氣，每個團隊和部門爭相嘗試 MCP 的應用，雖然已經知道近期的團隊 roadmap 會導入 MCP，但目前還沒想到能帶來巨大效益的應用。</p><p>聽說現在要跑起一個 MCP server 並不難，只要有 agent 就能夠開發和測試了，不論是用 Google ADK, Claude 或是 Roo Code，趕緊找一個手邊能用的玩玩看再說。</p><img src="/2025-08-29/play-mcp-with-roo-code/image-0.png" class=""><h2 id="專案設定"><a href="#專案設定" class="headerlink" title="專案設定"></a>專案設定</h2><p>本文將以 VS Code 的 Roo Code 套件作為範例，示範如何連接自建的 MCP 伺服器。這個伺服器本身是獨立的，因此你也可以使用其他支援 MCP 的 agent 來連接，例如 Google ADK 或 Claude。</p><p>首先，建立專案目錄並使用 <code>uv</code> 初始化環境。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> mcp-demo &amp;&amp; <span class="hljs-built_in">cd</span> mcp-demo<br><br>$ uv init<br><br>$ uv add <span class="hljs-string">&quot;mcp[cli]&quot;</span> <span class="hljs-string">&quot;uvicorn[standard]&quot;</span><br></code></pre></td></tr></table></figure><p>接著建立 <code>main.py</code> 來啟動 FastAPI 以及 FastMCP。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># filepath: mcp-demo/main.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> mcp.server.fastmcp <span class="hljs-keyword">import</span> FastMCP<br><br>mcp = FastMCP()<br>mcp_app = mcp.streamable_http_app()<br><br>app = FastAPI(<br>  lifespan=mcp_app.router.lifespan_context,<br>)<br><br>app.mount(<span class="hljs-string">&quot;/&quot;</span>, app=mcp_app)<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_root</span>() -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;FastAPI server is running. MCP is mounted at /mcp&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>接著來寫一段 code 建立 MCP tool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># filepath: mcp-demo/main.py</span><br><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">magic_add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Add two numbers with a magic formula.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span> * b + <span class="hljs-number">3</span> * a * b<br></code></pre></td></tr></table></figure><p>使用以下指令啟動伺服器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ uvicorn main:app --port 8000 --reload<br></code></pre></td></tr></table></figure><p>接著在 Roo Code 找到 MCP Servers 的面板，選擇 <code>Edit Project MCP</code> 後會自動打開 <code>.roo/mcp.json</code> 檔案作編輯。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Test Server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;streamable-http&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:8000/mcp&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;disabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alwaysAllow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>這邊是告訴 Roo Code (agent) 我們有一個名叫 Test Server 的 MCP server 使用 <code>streamable-http</code> 來和 agent 溝通，並 host 在 localhost:8000。如果是要串接外部的 MCP server 把 type 和 url 稍作修改即可。</p><p>接著到 Roo Code 的 MCP Servers 選單看看有沒有連上 (在 Console 中會看到 API 被呼叫的 log)。</p><img src="/2025-08-29/play-mcp-with-roo-code/image-1.png" class=""><p>如果這邊能夠正確顯示 tool 的內容，就是成功了。</p><p>如果遇到 404 或是 Error log 顯示 <code>RuntimeError: Task group is not initialized. Make sure to use run()</code></p><p>那很可能是 MCP server 沒有正確啟動，或是 URL 路徑設錯。如果是要把 MCP server 掛在 FastAPI 的一個 route 中的話，在 main.py 中的這行很重要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">app = FastAPI(<br>  lifespan=mcp_app.router.lifespan_context,<br>)<br></code></pre></td></tr></table></figure><p>接著來用 Roo Code 下個 prompt 測試吧</p><img src="/2025-08-29/play-mcp-with-roo-code/image-2.png" class=""><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這邊展示了如何快速建立一個 MCP server，之後會再補上如何利用 Google ADK 進行開發，以及 agent 是如何和 MCP server 溝通的。</p>]]></content>
    
    
    <categories>
      
      <category>技術筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MCP</tag>
      
      <tag>Roo Code</tag>
      
      <tag>FastAPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>試用新世代的 Python 套件管理工具 - uv</title>
    <link href="/2025-08-16/introduction-to-uv/"/>
    <url>/2025-08-16/introduction-to-uv/</url>
    
    <content type="html"><![CDATA[<img src="/2025-08-16/introduction-to-uv/image-0.png" class=""><h2 id="什麼是-uv"><a href="#什麼是-uv" class="headerlink" title="什麼是 uv?"></a>什麼是 uv?</h2><p>在介紹 uv 前，必須提到開發的公司 Astral，也就是開發大名鼎鼎的 Python formatter <strong>ruff</strong> 的公司。他們的野心就是要打造 Python 生態系中最好用的工具。</p><p>uv 就是由 Astral 開發的新一代 Python 套件與環境管理工具。<br>特色是用 Rust 寫的，主打極高速、低記憶體用量，並且把傳統上要用多個工具才能完成的功能（例如 pip、pip-tools、pipx、virtualenv、pyenv）整合到同一個 CLI 中。</p><p>簡單說，uv 讓你可以：</p><ul><li>管理相依套件及 lock file（pyproject.toml &#x2F; uv.lock）</li><li>建立與管理虛擬環境</li><li>安裝與切換 Python 版本</li><li>安裝 CLI 工具（類似 pipx）</li><li>發佈套件到 PyPI</li></ul><h2 id="一起來回顧目前在開發-Python-應用程式時的作法"><a href="#一起來回顧目前在開發-Python-應用程式時的作法" class="headerlink" title="一起來回顧目前在開發 Python 應用程式時的作法"></a>一起來回顧目前在開發 Python 應用程式時的作法</h2><p>如果不使用 Docker 或是 VS Code Dev Containers 開發的話，應該不會和下面這個流程差太多。</p><p>Step 1: 需要先指定 Python 版本，可能用 pyenv、pipenv 或 conda 來鎖定 Python 版本。</p><p>Step 2: 如果前一步的工具沒有附帶虛擬環境，可能就要再使用 Python venv、virtualenvwrapper 或是 poetry 這樣的工具來建立虛擬環境。</p><p>Step 3: 套件管理工具如 pip、poetry、conda 開始幫你解析並安裝相依套件。</p><p>如果使用 poetry 的話，至少要搭配 pyenv 來一起使用，稍嫌麻煩。</p><hr><h2 id="uv-的優勢"><a href="#uv-的優勢" class="headerlink" title="uv 的優勢"></a>uv 的優勢</h2><p>相信有過自行管理 Python 虛擬環境的人應該都能體會這有多麻煩，而 uv 的優勢就不言而喻了。</p><p>uv 讓我們可以：</p><ol><li>用極快的速度安裝專案需要的套件，特別利於在 CI&#x2F;CD 需要 build image，或是需要多環境的測試下減少大量的時間。</li><li>在一個新環境或專案中不用頻繁地安裝切換工具，學習成本變低，提升開發者體驗（DevEx）。</li><li>遵守 PEP 518&#x2F;621，使用 <code>pyproject.toml</code> 來管理相依套件，即使哪天不想用 uv，也能快速切換到支援 <code>pyproject.toml</code> 的工具如 poetry。</li></ol><hr><h2 id="uv-常用的指令"><a href="#uv-常用的指令" class="headerlink" title="uv 常用的指令"></a>uv 常用的指令</h2><h3 id="安裝-uv（macOS-Linux）"><a href="#安裝-uv（macOS-Linux）" class="headerlink" title="安裝 uv（macOS &#x2F; Linux）"></a>安裝 uv（macOS &#x2F; Linux）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LsSf https://astral.sh/uv/install.sh | sh<br></code></pre></td></tr></table></figure><h3 id="初始化專案"><a href="#初始化專案" class="headerlink" title="初始化專案"></a>初始化專案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> demo-uv &amp;&amp; <span class="hljs-built_in">cd</span> demo-uv<br>uv init<br></code></pre></td></tr></table></figure><h3 id="安裝-同步套件"><a href="#安裝-同步套件" class="headerlink" title="安裝&#x2F;同步套件"></a>安裝&#x2F;同步套件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv add fastapi<br>uv add --dev pytest ruff<br></code></pre></td></tr></table></figure><p>如果拿到別人給的 <code>pyproject.toml</code> 有更新，可以使用以下指令同步相依套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv <span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><p><code>uv sync</code> 會根據 <code>pyproject.toml</code> 和 <code>uv.lock</code> 的內容，安裝或更新專案所需的所有相依套件，確保環境與設定檔一致。</p><h3 id="執行程式"><a href="#執行程式" class="headerlink" title="執行程式"></a>執行程式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv run python -c <span class="hljs-string">&quot;import fastapi; print(fastapi.__version__)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="安裝特定-Python-版本"><a href="#安裝特定-Python-版本" class="headerlink" title="安裝特定 Python 版本"></a>安裝特定 Python 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv python install 3.12<br></code></pre></td></tr></table></figure><h3 id="設定專案使用版本"><a href="#設定專案使用版本" class="headerlink" title="設定專案使用版本"></a>設定專案使用版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv python pin 3.12<br></code></pre></td></tr></table></figure><h3 id="輸出成-pip-可以使用的-requirements-txt"><a href="#輸出成-pip-可以使用的-requirements-txt" class="headerlink" title="輸出成 pip 可以使用的 requirements.txt"></a>輸出成 pip 可以使用的 requirements.txt</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv <span class="hljs-built_in">export</span> &gt; requirements.txt<br></code></pre></td></tr></table></figure><hr><h2 id="比較-uv-和-pip-的安裝速度"><a href="#比較-uv-和-pip-的安裝速度" class="headerlink" title="比較 uv 和 pip 的安裝速度"></a>比較 uv 和 pip 的安裝速度</h2><p>分別用 pip 和 uv 來安裝 <code>pandas</code>：</p><img src="/2025-08-16/introduction-to-uv/image-1.png" class=""><p>從上圖可以看到，pip 的安裝速度相對較慢，特別是在解析相依套件時。</p><img src="/2025-08-16/introduction-to-uv/image-2.png" class=""><p>而使用 uv 時，安裝速度明顯更快，特別是在處理相依套件的解析與安裝過程中，速度提升了 40 倍。</p><hr><h2 id="測試-uv-在-Docker-中的表現"><a href="#測試-uv-在-Docker-中的表現" class="headerlink" title="測試 uv 在 Docker 中的表現"></a>測試 uv 在 Docker 中的表現</h2><p>底下三個測試都用差不多的 Dockerfile，差別只在安裝 Python 套件的方式。</p><h3 id="Case-1-使用-uv-pip"><a href="#Case-1-使用-uv-pip" class="headerlink" title="Case 1: 使用 uv pip"></a>Case 1: 使用 uv pip</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.10</span>-slim<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install --upgrade pip &amp;&amp; pip install uv</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> pyproject.toml uv.lock /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> uv <span class="hljs-built_in">export</span> --no-hashes --no-dev -o requirement.txt</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> uv pip install --system -r requirement.txt</span><br></code></pre></td></tr></table></figure><img src="/2025-08-16/introduction-to-uv/image-3.png" class=""><h3 id="Case-2-使用-uv-sync"><a href="#Case-2-使用-uv-sync" class="headerlink" title="Case 2: 使用 uv sync"></a>Case 2: 使用 uv sync</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.10</span>-slim<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install --upgrade pip &amp;&amp; pip install uv</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> pyproject.toml uv.lock /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> uv <span class="hljs-built_in">sync</span> --frozen --no-dev</span><br></code></pre></td></tr></table></figure><img src="/2025-08-16/introduction-to-uv/image-4.png" class=""><h3 id="Case-3-使用-pip"><a href="#Case-3-使用-pip" class="headerlink" title="Case 3: 使用 pip"></a>Case 3: 使用 pip</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.10</span>-slim<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install --upgrade pip &amp;&amp; pip install uv</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> pyproject.toml uv.lock /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> uv <span class="hljs-built_in">export</span> --no-hashes --no-dev -o requirement.txt</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirement.txt</span><br></code></pre></td></tr></table></figure><img src="/2025-08-16/introduction-to-uv/image-5.png" class=""><p>從這個測試可以看到，不論是使用 <code>uv pip</code> 或是 <code>uv sync</code>，花費的時間都是差不多的，而且遠快於直接使用 pip 安裝。</p><hr><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>uv 最近是社群炙手可熱的套件，其優異的效能以及開發體驗讓很多開發者直接愛上。建議大家都體驗看看，如果真的有遇到問題，退回去使用 poetry 也不會是很困難的一件事。</p>]]></content>
    
    
    <categories>
      
      <category>技術筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>套件管理</tag>
      
      <tag>uv</tag>
      
      <tag>Poetry</tag>
      
      <tag>pip</tag>
      
      <tag>pyenv</tag>
      
      <tag>virtualenv</tag>
      
      <tag>Docker</tag>
      
      <tag>PEP 518</tag>
      
      <tag>PEP 621</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讀書心得 | 生時間:高績效時間管理術</title>
    <link href="/2025-08-08/make-time-reading-notes/"/>
    <url>/2025-08-08/make-time-reading-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="生時間-高績效時間管理術-四個步驟，找回自己的時間"><a href="#生時間-高績效時間管理術-四個步驟，找回自己的時間" class="headerlink" title="生時間:高績效時間管理術 - 四個步驟，找回自己的時間"></a>生時間:高績效時間管理術 - 四個步驟，找回自己的時間</h1><p>本書由設計衝刺（Design Sprint）兩位共同發明人 Jake Knapp 和 John Zeratsky 撰寫。他們自稱「時間雙傻」，提出了一個全新的時間管理概念：「生時間（Make Time）」。</p><p>「生時間」是一個簡單的框架，僅用四個步驟就能在一天之中把時間留給自己最重要的「精華」。分別是:</p><ol><li><p><b>精華（Highlight）：</b>選出一天中最想完成的一件事，不一定是工作，也可以是陪家人、閱讀或創作。</p></li><li><p><b>雷射（Laser）： </b>運用策略排除干擾、專注在精華上。書中提供了 40 多種方法。</p></li><li><p><b>提振活力（Energize）： </b>透過運動、飲食與睡眠，提升身心能量。</p></li><li><p><b>反省（Reflect）： </b>每天檢討當天安排與策略，持續優化系統。</p></li></ol><div style="margin: 1.5em 0 1.5em 0;">    <img src="/2025-08-08/make-time-reading-notes/image-1.png" class=""></div><p>我想分別列出四個步驟中自己覺得很有趣耳目一新的策略:</p><h3 id="精華策略"><a href="#精華策略" class="headerlink" title="精華策略"></a>精華策略</h3><ol><li><p>書中提供了作者的行事曆範例，其中將「精華任務」明確地安排在每天的時間區塊上，這是一種對自己下承諾的方式。我注意到 Google 的員工也常在行事曆中加入任務與待辦，這點在一些公開演講與工作分享中也有出現。不禁讓人好奇：這是文化習慣，還是公司內部的默契呢？</p></li><li><p>每個人的精華時間都不同，有些人是「晨型人」有些人是「夜型人」，基因決定我們的精華時間，如果早上真的起不來，可能不是你的錯，另外找尋精華時間吧。</p></li></ol><h3 id="提振活力"><a href="#提振活力" class="headerlink" title="提振活力"></a>提振活力</h3><ol><li>像原始人一樣生活: 假想你有一個從古代穿越來的原始人朋友，模仿他做什麼、吃什麼你就能獲得一樣的能量和健康的身體。人類的身體是被設計來勞動不是久坐的，原始人一天之中要經歷狩獵、逃跑、採集等大量勞力工作，現在人的活動量嚴重不足。原始人吃的都是原型未加工的食物，專挑這種吃就對了，大量的蔬菜、水果、堅果等食物都能幫助身體排毒修復帶來活力。</li><li>正確喝咖啡的時間可以事半功倍: 書中有提到咖啡因提神的原理是咖啡因能阻斷讓人產生疲勞感的腺苷和大腦受器結合，欺騙大腦不會累，中午可以利用小睡前先喝咖啡，然後去睡覺，待咖啡因吸收差不多了，起來時馬上就能覺得精神百倍。</li></ol><h2 id="讀完本書後我採取的行動"><a href="#讀完本書後我採取的行動" class="headerlink" title="讀完本書後我採取的行動"></a>讀完本書後我採取的行動</h2><ol><li>我像原始人一樣行動，能走樓梯不搭電梯，搭大眾運輸能站不坐，每天會可刻意走路和爬樓梯到手錶推薦的目標。</li><li>嘗試在到辦公室時，先花一點時間規劃今天的目標，跳過已經排定的會議，將一個一個任務排進今天的行事曆，這樣像是在對自己以及其他人宣告，這段時間我就是要完成這個任務。</li></ol><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>因為看到社群太多人推薦這本書，馬上就買來看，和一般時間管理或是教人提高績效的書不同的是，這本書只強調一天當中的那個精華，我們使用各種雷射策略以及提振活力為的就是要確保在一天中能夠執行我們所選出的「精華」。</p><p>很喜歡書中提到的一概念：每日可以確實完成的事項才是成就感的來源，不必在每日的精華時間都拍定一個非常厲害高尚目標，反而是把一個大目標切碎，每日按部就班落實更能帶來快樂。</p><p>因為現在每日都有反思的習慣，有觀察到自己的意志力會隨著體力的消耗而降低，到了晚上把小孩趕上床後意志力已經所剩無幾，這個時候要求自己學習實在是太痛苦，未來可能會嘗試當個「晨型人」，將一天中最有精神的時間留給自己。</p><p>書中特別提醒我們：不需要像網路上的部落客或 Youtuber 一樣，過著「早起、精實又完美」的一天。這些追求完美的生活方式，有時反而會分散注意力、加重焦慮。這段話真讓人感到安慰。</p><blockquote><p>沒有人可以一直當完美的饕客，有完美的生產力、完美的覺察力，又得到完美的休息。</p></blockquote><blockquote><p>我們就是做不到部落客說的，該在清晨五點前去做的 57 件事。其實，就算我們做得到，也不該這麼做。追求完美也會使人注意力不集中——這也是一個閃閃發亮，把你的注意力從真正要務拉走的目標。</p></blockquote><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li>生時間 Blog: <a href="https://maketime.blog/">https://maketime.blog/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>讀書心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>時間管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>誰吃了我的 zsh?! 在 GCP Workstation 使用 zsh 的方法</title>
    <link href="/2025-08-02/gcp-workstation-zsh/"/>
    <url>/2025-08-02/gcp-workstation-zsh/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近把公司的開發環境從虛擬機器移到 GCP 上 Cloud Workstation（以下都稱為 Workstation），設定完基本的開發環境（如 Python、NVM、Vim 等工具）後就開始開發了。但因為公司的政策，Workstation 會 Idle shutdown，某次重開後發現我的 zsh 居然消失了！</p><span id="more"></span><p>後來在<a href="https://cloud.google.com/workstations/docs/architecture?hl=zh-tw">官方文件</a>看到裡面有提到一段：</p><blockquote><p>永久磁碟：連結至工作站 VM 並掛接至 &#x2F;home 資料夾的永久磁碟，可讓您在工作階段結束後儲存資料和檔案。</p></blockquote><p>才知道在 Cloud Workstation 中，只有 <code>/home</code> 目錄的檔案會被保留，那就表示如果要在 Cloud Workstation 使用 zsh，用 <code>apt install</code> 是行不通的！</p><p>如果想跳過測試過程，直接查看安裝步驟，可以參考<a href="#%E6%87%B6%E4%BA%BA%E5%8C%85">懶人包</a>。</p><h2 id="嘗試安裝的過程"><a href="#嘗試安裝的過程" class="headerlink" title="嘗試安裝的過程"></a>嘗試安裝的過程</h2><ol><li><p>Clone zsh 的原始碼並進入目錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh.git &amp;&amp; <span class="hljs-built_in">cd</span> zsh<br></code></pre></td></tr></table></figure></li><li><p>因為 zsh 的 master 是開發測試 branch，要找穩定版需要透過 tag 去找 branch，例如安裝正式版 5.9：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout tags/zsh-5.9 -b zsh-5.9<br></code></pre></td></tr></table></figure></li><li><p>自己 build 的說明文件寫在 INSTALL 中，文件第一步是設定 configure，所以執行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./configure --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>來查看說明。</p></li><li><p>遇到第一個問題：clone 回來的 zsh 目錄沒有 configure 檔案！</p></li><li><p>再次查看文件，發現如果沒有 configure 的話需要先執行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./Util/preconfig<br></code></pre></td></tr></table></figure><p>但執行後失敗了，似乎缺少某些套件。</p></li><li><p>透過 ChatGPT 得知需要 Autotools 來輔助 Makefile，並安裝相關套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install -y autoconf automake libtool<br></code></pre></td></tr></table></figure><p>再次執行 <code>./Util/preconfig</code>，應該就會成功。</p></li><li><p>接著用 configure 來設定輸出的目錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./configure --prefix=<span class="hljs-variable">$HOME</span>/.local/zsh<br></code></pre></td></tr></table></figure><p>（這裡將 zsh 安裝在 <code>~/.local/zsh</code> 中）。</p></li><li><p>遇到以下錯誤：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">configure: error: <span class="hljs-comment">&quot;No terminal handling library was found on your system.</span><br>This <span class="hljs-keyword">is</span> probably <span class="hljs-keyword">a</span> library called <span class="hljs-string">&#x27;curses&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-string">&#x27;ncurses&#x27;</span>.  You may<br>need <span class="hljs-keyword">to</span> install <span class="hljs-keyword">a</span> package called <span class="hljs-string">&#x27;curses-devel&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-string">&#x27;ncurses-devel&#x27;</span> <span class="hljs-keyword">on</span> your<br><span class="hljs-built_in">system</span>.<span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>缺少套件，安裝 <code>libncursesw5-dev</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install -y libncursesw5-dev<br></code></pre></td></tr></table></figure></li><li><p>再次執行 configure，成功了！</p><img src="/2025-08-02/gcp-workstation-zsh/image-1.png" class=""></li><li><p>最後 build zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make install<br></code></pre></td></tr></table></figure></li><li><p>因為安裝的目錄在 <code>~/.local/zsh/</code>，所以執行測試時需要用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ~/.local/zsh/bin/zsh<br></code></pre></td></tr></table></figure><p>來測試。</p></li><li><p>如果一切正常，可以修改 <code>~/.bashrc</code>，讓啟動時自動開啟 zsh。為什麼不能用 <code>chsh</code> 來指定預設 Shell 呢？<br>因為在 Workstation 中，只有 <code>/home</code> 底下的檔案才不會消失，所以即使用了 <code>chsh</code>，下次啟動仍會使用預設的 bash。</p><p>修改 <code>~/.bashrc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ~/.bashrc</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.local/zsh/bin/zsh&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.local/zsh/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br>  <span class="hljs-built_in">exec</span> zsh<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure></li><li><p>重新啟動 Workstation，輸入 <code>echo $0</code>，如果成功顯示 <code>zsh</code>，那就大功告成了！</p></li></ol><h2 id="懶人包"><a href="#懶人包" class="headerlink" title="懶人包"></a>懶人包</h2><ol><li><p>更新並安裝必要的相依套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt update &amp;&amp; <span class="hljs-built_in">sudo</span> apt install -y \<br>  build-essential libncursesw5-dev libreadline-dev \<br>  libgdbm-dev libssl-dev libffi-dev libtool autoconf git<br></code></pre></td></tr></table></figure></li><li><p>Clone zsh 並切換到穩定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~<br>$ git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh.git<br>$ <span class="hljs-built_in">cd</span> zsh<br>$ git checkout tags/zsh-5.9 -b zsh-5.9<br></code></pre></td></tr></table></figure></li><li><p>設定 configure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./Util/preconfig<br></code></pre></td></tr></table></figure></li><li><p>安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./configure --prefix=<span class="hljs-variable">$HOME</span>/.local/zsh<br>$ make -j$(<span class="hljs-built_in">nproc</span>)<br>$ make install<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>~/.bashrc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt;&gt; ~/.bashrc<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;$HOME/.local/zsh/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;if [ -x &quot;$HOME/.local/zsh/bin/zsh&quot; ]; then exec zsh; fi&#x27;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure></li></ol><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>只是想在 Workstation 中用個 oh-my-zsh 居然搞了這麼久，不過這個經驗也滿有趣的，又稍微了解了一點 Workstation，另外要在自己電腦用 VS Code 連到 Workstation 的 VM 又是另一個故事了，改天在寫吧。</p>]]></content>
    
    
    <categories>
      
      <category>技術筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCP</tag>
      
      <tag>zsh</tag>
      
      <tag>Cloud Workstation</tag>
      
      <tag>Shell</tag>
      
      <tag>devtools</tag>
      
      <tag>Linux</tag>
      
      <tag>開發環境</tag>
      
      <tag>自動化工具</tag>
      
      <tag>雲端開發</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bigtable 和 BigQuery 都很 Big! 他們真的一樣嗎？</title>
    <link href="/2025-07-29/bigtable-vs-bigquery/"/>
    <url>/2025-07-29/bigtable-vs-bigquery/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>GCP 中的 Bigtable 和 BigQuery 對初學者來說很容易混淆，「都是資料庫而且都有 big 字首，用起來應該差不多吧?」這個就是我拋出來的疑問。在閱讀完<a href="https://cloud.google.com/blog/topics/developers-practitioners/bigtable-vs-bigquery-whats-difference">這篇</a> GCP blog 的文章後做了此摘要。</p><div style="width: 100%; display: flex; justify-content: center;">  <div><img src="/2025-07-29/bigtable-vs-bigquery/image-1.png" class=""></div></div><span id="more"></span><h3 id="從本質上來區分"><a href="#從本質上來區分" class="headerlink" title="從本質上來區分"></a>從本質上來區分</h3><p><b>Bigtable</b> 是一個 wide-column NoSQL database 用在需要低延遲，高吞吐量的使用情境，適合用作 OLTP (Online Transaction Processing)</p><blockquote><p>Bigtable is a NoSQL wide-column database optimized for heavy reads and writes.</p></blockquote><p><b>BigQuery</b> 則是企業級資料倉儲，用來作 OLAP (Online Analytical Processing) 用途</p><blockquote><p>BigQuery is an enterprise data warehouse for large amounts of relational structured data.</p></blockquote><h3 id="特性比較"><a href="#特性比較" class="headerlink" title="特性比較"></a>特性比較</h3><table><thead><tr><th>特性項目</th><th><strong>Bigtable</strong></th><th><strong>BigQuery</strong></th></tr></thead><tbody><tr><td>類型</td><td>Wide-Column NoSQL</td><td>Data Warehouse</td></tr><tr><td>主要用途</td><td>即時寫入讀出、OLTP (無 Transaction)</td><td>離線分析、報表查詢、OLAP</td></tr><tr><td>應用場合</td><td>高吞吐量的應用程式（IoT、AdTech、ML 等）</td><td>大量資料分析、報表統計、BI、SQL 查詢、ML</td></tr><tr><td>查詢方式</td><td>以 Row Key 為主的 API &#x2F; SDK 操作</td><td>標準 SQL 查詢</td></tr><tr><td>延遲表現</td><td>毫秒等級</td><td>秒～十秒以上</td></tr><tr><td>吞吐量擴展</td><td>水平擴展：每加一節點可處理約 10,000 QPS</td><td>虛擬資源，根據查詢負載自動擴展</td></tr><tr><td>資料寫入方式</td><td>高頻寫入，每筆資料可自定欄位，適合大資料量</td><td>批次或串流寫入，用於歷史資料分析</td></tr><tr><td>資料量規模</td><td>TB ～ PB 級</td><td>PB 級</td></tr><tr><td>整合性</td><td>支援 HBase API；整合 Hadoop、Dataflow、Dataproc</td><td>整合 Looker、Data Studio、AI Platform 等</td></tr><tr><td>計費方式</td><td>根據節點與儲存空間收費</td><td>根據掃描資料量計費</td></tr></tbody></table><h3 id="Bigtable-和-BigQuery-共同的特性"><a href="#Bigtable-和-BigQuery-共同的特性" class="headerlink" title="Bigtable 和 BigQuery 共同的特性"></a>Bigtable 和 BigQuery 共同的特性</h3><ol><li>兩個都是雲原生的設計，能夠享用供應商提供的託管服務及雲端架構的優勢</li><li>高達 99.99% SLA</li><li>自動 Sharding 不用在人工處理邏輯</li><li>自動故障修復</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>原文中提到：</p><blockquote><p>It is safe to say that you would serve an application that uses Bigtable as the database but most of the times you wouldn’t have applications performing BigQuery queries.</p></blockquote><p>這句話讓我反思公司內部的使用情境。有些專案團隊確實使用 BigQuery 作為應用程式的資料庫，但也因此遇到 API 回應時間的效能瓶頸。這可能是因為查詢需要大量資料聚合，例如繪製圖表時的操作。雖然 BigQuery 的基本開銷較高，但在某些情境下，省下的時間效益可能超過成本。</p><h4 id="可能在公司使用-Bigtable-的情境"><a href="#可能在公司使用-Bigtable-的情境" class="headerlink" title="可能在公司使用 Bigtable 的情境"></a>可能在公司使用 Bigtable 的情境</h4><p>我們部門主要進行資料視覺化，應用程式需要即時撈取所選區間的資料並繪製成圖表。這類情境通常是讀多寫少，QPS 很低，但對 API 回應時間要求很高，且不需要 Transaction。基於 Bigtable 的低延遲特性，它可能是這類應用程式的理想選擇。</p><h4 id="可能在公司使用-BigQuery-的情境"><a href="#可能在公司使用-BigQuery-的情境" class="headerlink" title="可能在公司使用 BigQuery 的情境"></a>可能在公司使用 BigQuery 的情境</h4><p>我曾設計過一個 Web Analytics 服務，用來追蹤系統使用者行為。這類情境不需要即時讀寫，但需要一次分析大量資料，非常適合使用 BigQuery。它的 SQL 支援和資料聚合能力能有效處理這類需求。</p><p>此筆記用來幫自己快速了解兩個服務的區別，比較可惜的是原文只有大概介紹區別以及特性，沒有講太多實作，未來有機會在深入研究 Bigtable 如 row key 這樣的設計。</p><h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><ul><li>OLTP (Online Transaction Processing): 適合即時讀寫，例如用戶登入、下單。</li><li>OLAP (Online Analytical Processing): 適合查大量資料做統計報表。</li><li>SLA：服務可用性保證，例如 99.99% 表示一年最多可能停機 52 分鐘。<br><strong>附註</strong>：計算方式為 <code>365 天 × 24 小時 × 60 分鐘 × (1 - SLA)</code>，例如 99.99% SLA 的停機時間為 <code>365 × 24 × 60 × 0.01% = 52 分鐘</code>。</li><li>NoSQL：一種不走傳統關聯式資料表設計的資料庫類型，表的設計會依據查詢的方式來設計，不會看到傳統的正規化設計。常見有 key-value（Redis）、document（MongoDB）、wide-column（Bigtable）等。</li><li>雲原生：為雲端架構而設計的系統，強調自動擴展、自動修復、免維運。</li><li>QPS：每秒查詢次數，數字越高代表系統越能撐過高流量的負載。</li><li>Sharding：把資料分散存放到不同機器上，為了擴展與加速。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>GCP Blog: <a href="https://cloud.google.com/blog/topics/developers-practitioners/bigtable-vs-bigquery-whats-difference">Bigtable vs. BigQuery: What’s the difference?</a></p>]]></content>
    
    
    <categories>
      
      <category>技術筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCP</tag>
      
      <tag>Bigtable</tag>
      
      <tag>BigQuery</tag>
      
      <tag>Beginner</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025 郵輪之旅 基隆-長崎-鹿兒島-那霸 (下)</title>
    <link href="/2025-07-24/2025-cruise-travel-2/"/>
    <url>/2025-07-24/2025-cruise-travel-2/</url>
    
    <content type="html"><![CDATA[<h2 id="長崎上陸"><a href="#長崎上陸" class="headerlink" title="長崎上陸"></a>長崎上陸</h2><p>這天是這趟航程中在陸上時間最久的，加上想去的景點都在電車可以到達的位置，所以長崎港的行程就全部自由行。</p><p>必去的哥巴拉園離港口很近，不想走路爬坡上去的話可以直接包計程車坐上去，要注意哥巴拉園有兩個入口一個在天主堂旁邊一個在整個花園最上面，記得跟司機講清楚要在那邊下車，才不會出現跟我們一樣叫了兩部車結果在不同入口找不到人的笑話。</p><p>推薦搭車到花園上方的入口，接著一路散步下來是最省時省力的路線。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-2.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-3.jpg" class=""></div><div style="display: flex; justify-content: space-evenly">  <div style="padding: 5px; width: 48%">    <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-1.jpg" class="">  </div>  <div style="padding: 5px; width: 48%">    <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-5.jpg" class="">  </div></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-4.jpg" class=""></div><div style="width: 100%; text-align: center;">園區附近的小店家</div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/glover-garden-6.jpg" class=""></div><div style="width: 100%; text-align: center;">遠眺長崎市景</div></br><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-24/2025-cruise-travel-2/tram.jpg" class="">  </div></div><div style="width: 100%; text-align: center;">在長崎可以靠著路面電車移動，我們的第二站是諏訪神社。</div></br><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/suwa-jinja-2.jpg" class=""></div><div style="width: 100%; text-align: center;">從正門上去的話就會經過這排雄偉的鳥居，因為有推嬰兒車，我們選擇繞路從後面車道上去。</div></br><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-24/2025-cruise-travel-2/suwa-jinja-4.jpg" class="">  </div></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/suwa-jinja-1.jpg" class=""></div><div style="width: 100%; text-align: center;">神社裡面的角落都很好拍</div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/suwa-jinja-3.jpg" class=""></div><p>參訪完諏訪神社後距離上船還有一段時間，加上電車路線也順路，我們在安排了浜町商店街的購物行程。</p><p>在這邊可以買到很多東西，長崎蛋糕如果不想跑去福砂屋本店，這邊也有分店可以買。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/hamamachi-2.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/hamamachi-1.jpg" class=""></div><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-24/2025-cruise-travel-2/hamamachi-3.jpg" class="">  </div></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/hamamachi-4.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/hamamachi-5.jpg" class=""></div><p>晚上在郵輪上盡情的拍攝夜景，這趟很可惜因為時間不夠，不然很想上去稻佐山拍攝夜景。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/nagasaki-nightview-1.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/nagasaki-nightview-2.jpg" class=""></div><h2 id="鹿兒島上陸"><a href="#鹿兒島上陸" class="headerlink" title="鹿兒島上陸"></a>鹿兒島上陸</h2><p>鹿兒島想去的點比較多，加上電車不順路，這天我們決定直接包車，事後覺得真的非常划算，不僅節省時間，車上也可以好好休息。</p><p>鹿兒島在過去被稱為薩摩藩，和明治維新有密切關聯：鹿兒島正是西鄉隆盛活躍的舞台，在這邊可以看到很多和西鄉隆盛相關的遺跡。</p><p>聽從領隊的建議，第一站直接衝上城山公園展望台一覽城市美景。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-1.jpg" class=""></div><div style="width: 100%; text-align: center;">城山公園展望台</div><p>接著趕著去鹿兒島水族館看上午十一點的海豚表演。水族館不大，可以來吹冷氣走走，因為鹿兒島實在太熱，還是需要安排這種室內的輕鬆行程。</p><p>中午在著名的天文館商店街用餐，鹿兒島有名的是黑豬和黑牛，因此找間燒肉火鍋是必須的！</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-2.jpg" class="">  </div></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-3.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-5.jpg" class=""></div><div style="width: 100%; text-align: center;">天文館商店街</div></br><p>最後一站是著名景點仙巖園，仙巖園原本是島津家的別邸，篤姬在出嫁前曾在這邊生活。島津的後代改名為仙巖園並開放給民眾參觀。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-4.jpg" class=""></div><div style="width: 100%; text-align: center;">鹿兒島著名的觀光景點：仙巖園</div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-6.jpg" class=""></div><div style="width: 100%; text-align: center;">全日本唯一的貓神社</div><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-7.jpg" class="">  </div></div><div style="width: 100%; text-align: center;">鹿兒島實在有夠熱，在港口旁居然有餐車在賣冰涼的咖啡，實在太邪惡</div></br><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-8.jpg" class=""></div><div style="width: 100%; text-align: center;">  這是我最喜歡的一個角度，從船上可以清楚看到港口邊熱情的日本團體來送行，後方是美麗的櫻島</div></br><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-9.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/kagoshima-10.jpg" class=""></div><div style="width: 100%; text-align: center;">最後送上一張從海上拍到的美麗櫻島</div><h2 id="那霸上陸"><a href="#那霸上陸" class="headerlink" title="那霸上陸"></a>那霸上陸</h2><p>郵輪的最後一站是那霸，這天也是在陸上時間最短的，下午才到港。</p><p>因為家人有些人是第一次來沖繩，所以我們分成兩組人：一組帶小朋友去海灘玩沙；另一組去參觀波上宮。</p><p>當天天氣非常炎熱，走在橋上直接曝曬烘烤，感覺皮膚正在一寸一寸的熔化。但是在看到清澈的海水後，暑氣又瞬間被帶走了。</p><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/okinawa-1.jpg" class=""></div><div style="width: 100%; text-align: center;">藍天白雲和清澈海水，這就是沖繩</div></br><div style="display: flex; justify-content: space-evenly">  <div style="padding: 5px; width: 48%">    <img src="/2025-07-24/2025-cruise-travel-2/okinawa-3.jpg" class="">  </div>  <div style="padding: 5px; width: 48%">    <img src="/2025-07-24/2025-cruise-travel-2/okinawa-2.jpg" class="">  </div></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/okinawa-4.jpg" class=""></div><div style="width: 100%; text-align: center;">為了拍美景的代價就是走在橋上被烤熟</div></br><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/okinawa-5.jpg" class=""></div><div style="width: 100%; text-align: center;">第一次一定要來的國際通</div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/okinawa-7.jpg" class=""></div><div style="padding: 5px">  <img src="/2025-07-24/2025-cruise-travel-2/okinawa-8.jpg" class=""></div><div style="width: 100%; text-align: center;">停留時間不多，但還是很喜歡國際通的街景</div></br><p>因為怕小孩餓壞，來不及走到原本查好的餐廳只好在國際通隨便找一家吃，意外的找到一家不錯的餐廳，裡面有各種沖繩料理，海葡萄、塔可飯沖繩麵條都有。</p><p>但店員私心推薦要點拉麵，我一開始還想說這種店的拉麵怎麼會好吃，但送上來一試驚為天人，馬上被分食掉，原本桌上擺滿的食物瞬間黯然失色。</p><p>沖繩只能說是稍作停留，排一到兩個行程就差不多了。</p><p>這趟六天的郵輪和家人一起度過很充實，小朋友也完得很開心，整趟回台灣胖了兩公斤。</p>]]></content>
    
    
    <categories>
      
      <category>旅遊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅遊</tag>
      
      <tag>攝影</tag>
      
      <tag>日本</tag>
      
      <tag>2025</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025 郵輪之旅 基隆-長崎-鹿兒島-那霸 (上)</title>
    <link href="/2025-07-20/2025-cruise-travel-1/"/>
    <url>/2025-07-20/2025-cruise-travel-1/</url>
    
    <content type="html"><![CDATA[<p>一直想要帶家人搭一趟郵輪，體驗悠哉放空的行程，剛好親友揪了一團家族旅遊我們索性就跟團了。</p><p>上一次搭乘郵輪旅遊已經是 2019 的事了，和上次不同的是，這趟旅程多了幾位新成員，對於 2025 再次搭乘郵輪感到無比興奮。</p><span id="more"></span><h2 id="行前-＆-登船"><a href="#行前-＆-登船" class="headerlink" title="行前 ＆ 登船"></a>行前 ＆ 登船</h2><p>這次搭乘的是麗星郵輪的探索星號，前身聽說是名勝郵輪。</p><p>行程如下：</p><p><b>第一天 (基隆) -&gt; 第二天 (船上) -&gt; 第三天 (長崎) -&gt; 第四天 (鹿兒島) -&gt; 第五天 (沖繩) -&gt; 第六天 (基隆)</b></p><p>郵輪從基隆港出發，因為要帶小孩還有大包小包的行李，我們當天是直接開車到基隆港，停在有點距離的停車場後再轉搭計程車去郵輪碼頭。</p><p>這樣做的好處是可以省去找停車場的時間，而且停車場可以事前預也能知道停放期間的總費用 （但旅行回來後非常後悔開車從台中開到台北，下一趟還是考慮火車或高鐵好了）。</p><p>要特別注意是在東岸登船還是西岸，跑錯可能會影響到托運行李和報到時間，務必事前確認好。</p><p>我們出發是在東岸登船，13:30 報到，要先到一樓托運行李完成後再到二樓辦理報到，托運和報到都需要排隊，所以建議提早到把手續都弄完就可以安心等登船了。</p><p>在報到櫃台領取房卡時，如果沒有特別提出要領取房卡掛繩櫃台是不會主動給的，而且數量有限記得要跟櫃台說。</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/keelungisland.jpg" class="">  </div></div><div style="width: 100%; text-align: center;">基隆嶼</div><hr><p>登船時會驗證你的身分，並收取護照，到整個行程結束結帳後才能領回，在日本行動時海關是以當初複印的 A4 護照影本作為身分的驗證。</p><p>如果沒有印這張或是遺失可是不能入境的，一定要妥善保管。</p><p>登船後就可以自由活動啦，大部分的人都會直接衝餐廳享用美食，行李的部分會在登船後陸續送到倉房的門口，如果有需要立即使用或重要的文件要隨身攜帶。</p><p>等到遊客都上船後，會先進行一次安全演練，所有遊客都需要到指定的集合地點集合，船員簡單示範完救生衣使用方式後就解散了，我想是因為流程很快速時間很短，聽到解散後大家都給予熱烈的掌聲。</p><h2 id="探索星號"><a href="#探索星號" class="headerlink" title="探索星號"></a>探索星號</h2><h3 id="露台客房"><a href="#露台客房" class="headerlink" title="露台客房"></a>露台客房</h3><p>因為不喜歡被關起來的感覺，在房型的選擇上選了露台房，雖然價錢會貴上一些，但有自己的露台可以吹吹海風，再加上能夠先下船我想是值得的。</p><p>探索星號的露台房我覺得兩個人可能是最剛好了，如果三人以上船員會將沙發床攤平併成第二張床，原本小客廳就不見了會讓房間變得很擠。我們家兩大一小住起來還滿剛好，連在一起的大床剛好可以作為小朋友的遊樂園。</p><p>電視能選的節目很少，沒有多媒體中心可以選擇節目，也無法自己接 HDMI 只能當作是個掛在牆上的裝飾品。</p><p>露台的落地窗有安全鎖，可以不用擔心兒童會輕易打開，露台外附了兩張小椅子和一張小桌，可以趁天氣好的時候在這邊看看書，看看海或放空，反正在船上就是時間最多嘛！</p><p>講個這次房間最不滿意的地方，每天晚上躺上床準備進入夢鄉時，總是會聽到蹦蹦蹦蹦的振動音還有音樂，本來想說可能是郵輪剛好有派對活動吧。<br>但是一天兩天到第三天每天都在吵，甚至是半夜還有音樂聲，心想不可能每天都有派對而且到這麼晚吧？上面肯定是酒吧之類的，為了一探究竟，某天晚上偷偷溜下床深怕驚動旁邊熟睡的小魔王，上樓看後，原來對應的是電子娛樂室，此時正好有一男一女開心的在玩跳舞機，這下終於真相大白了。</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/seaview-1.jpg" class="">  </div></div><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/seaview-2.jpg" class="">  </div></div><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/seaview-3.jpg" class="">  </div></div><div style="width: 100%; text-align: center;">船上限定無敵海景</div><h3 id="船上伙食"><a href="#船上伙食" class="headerlink" title="船上伙食"></a>船上伙食</h3><p>講到搭乘郵輪，除了娛樂大家應該最在意食物是不是很難吃了，先說結論，我覺得食物非常好吃！</p><p>探索星號上面總共有三間免費餐廳，以及各式付費餐廳，一個用餐時段可以選一個免費餐廳去吃，付費餐廳則不限。所以去付費餐廳吃不飽還可以去自助餐吃到飽。</p><p>免費餐廳有三家:</p><ol><li>麗都（自助餐）</li><li>星夢（中式合菜）</li><li>百味軒（西式套餐）</li></ol><p>付費餐廳有:</p><ol><li>藍湖 （亞洲料理）</li><li>絲路 （中式合菜）</li><li>星宴 （排餐）</li><li>燒烤餐廳</li><li>海馬（日本料理）</li></ol><p>露台房每天都有 1200 台幣的消費金可以使用，而且可以累計，也就是說第一天沒有使用的話到了第二天可以有 2400、第三天 3600 以此類推。</p><p>如果說免費餐廳是可以吃飽的等級，那付費餐廳可以說真的非常好吃。<br>絲路需要人多菜色才能多樣，而且可以多個房間拆帳付款，適合大家一起去吃，因為很熱門有路過的話可以提前先去預約。</p><p>藍湖是這次旅程吃過最多次的餐廳，裡面菜色非常多樣，特別是鹹酥雞吃起來口味和胖子雞丁很像，晚上想吃宵夜就去外帶一盤，從沒想過郵輪上可以有好吃的宵夜。</p><div style="padding: 5px">  <img src="/2025-07-20/2025-cruise-travel-1/blue-lagoon.jpg" class=""></div><div style="width: 100%; text-align: center;">漂亮的藍湖餐廳</div></br><p>其他幾家考慮到帶小孩麻煩就沒有去嘗試了，但這次六天五夜的旅行，吃的部分給過及格分數。</p><h3 id="船上設施"><a href="#船上設施" class="headerlink" title="船上設施"></a>船上設施</h3><p>因為有大半時間都在海上航行，在船上除了放空外還是需要找點事做，船上有很多設施，大部分都是要付費的。</p><ul><li><p>健身房：擁有無敵海景的健身房，沒有進去使用但在外面看到不少跑步機和飛輪機，如果不想在健身房跑步，甲板上也是有畫一個跑道，只是都離圍欄很近有點危險。</p></li><li><p>游泳池：非常不推的設施，高空滑水道有開放時間，中間的泳池水很深，連成人都踩不到底，不適合小朋友玩水。</p></li><li><p>VR 空間：還算可以，裡面有跳舞機、格鬥街機、賽車等，隔壁可以像網咖一樣付費包 PS4、PS5 來打，便宜很適合殺時間。</p></li><li><p>兒童遊戲室：大推，有帶小朋友的人可以每天帶來放電，裡面有很多玩具還有陪玩姊姊，另外有 Nintendo Switch 可以玩瑪利歐賽車，一天免費上限 2 小時，超過會額外收取費用。</p></li><li><p>七樓大廳，有些時段會開放乘客用超大螢幕玩 Switch，在這邊體驗和陌生人一起用大螢幕玩 Overcooked 也是一種新奇的體驗。</p></li><li><p>電動麻將桌：我覺得是整個郵輪上 CP 值最高的設施了，1000 台幣開一桌，可以打兩小時，還附每個人一杯水果茶，如果沒帶小孩我可能會整天都泡在這裡。</p></li><li><p>賭場：沒什麼興趣只有進去參觀而已。</p></li></ul><p>其他還有 SPA 芳療、按摩這些設施沒有去了解就不多說明了，總之在船上其實不會無聊，如果是三五好友一起出遊，有帶上桌遊的話反而會覺得時間怎麼這麼不夠。</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/starnavigator-1.jpg" class="">  </div></div><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 90%">    <img src="/2025-07-20/2025-cruise-travel-1/starnavigator-2.jpg" class="">  </div></div><h3 id="小知識"><a href="#小知識" class="headerlink" title="小知識"></a>小知識</h3><ol><li>房間走道的地毯是很多條鯉魚，魚頭的方向就是船頭，魚尾的方向就是船尾，只要上船後對各個設施的相對位置有概念，就不會迷路了。</li><li>船上可以透過 QR code 開啟郵報網頁，裡面會有每天的節目以及到港、離港時間。</li><li>本來想說在船上夠高，應該可以拍夜景吧就帶了腳架，但船移動時非常晃，腳架一點用都沒有，不如手持加上機身防抖。</li></ol><h3 id="和上次搭的鑽石公主號的差異"><a href="#和上次搭的鑽石公主號的差異" class="headerlink" title="和上次搭的鑽石公主號的差異"></a>和上次搭的鑽石公主號的差異</h3><ol><li>公主號的雙人露台房客廳的空間比較大，但床是上下鋪比較小，電視有兩台。</li><li>電視每天都會有新的電影可以選來看，雖然沒有中文字幕但我還是可以坐在沙發上看一整天。</li></ol><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>回程是三點左右到達基隆港，接著要開約四小時的車程回台中，想到就覺得累死。</p><p>大約開到汐止就開始暴雨，車流很多，視線很差所以車速也不快。屋漏偏逢連夜雨，開到一半發現胎壓在下降，幸好離新店交流道不遠，胎壓也沒有掉的很快剛好撐到交流道附近的輪胎行，有驚無險。</p><p>下一趟搭郵輪，我想我還是乖乖搭火車好了。</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 60%">    <img src="/2025-07-20/2025-cruise-travel-1/keelungharbor-1.jpg" class="">  </div></div><div style="width: 100%; text-align: center;">回程拍到美麗的基隆港</div>]]></content>
    
    
    <categories>
      
      <category>旅遊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅遊</tag>
      
      <tag>攝影</tag>
      
      <tag>日本</tag>
      
      <tag>2025</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拆解 Streamlit 的神秘資料流</title>
    <link href="/2025-07-17/streamlit-dataflow-experiment/"/>
    <url>/2025-07-17/streamlit-dataflow-experiment/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司在推行用 Streamlit 來建構專案的 prototype，讓資料科學家可以快速建立可互動的 UI。我自己試玩了一下覺得很不錯，只要寫點 Python code 就能快速生出漂亮的 UI 互動元件，自己刻可能都要花上一點時間。</p><span id="more"></span><p>在做 side project 的過程中，開始對它的架構產生興趣：在前端操作完 UI 元件後，後端是怎麼接收這個事件並做出回應的呢？打開 Debugger Tool 翻遍了所有 request 都沒看到疑似交換資料的 API call。</p><img src="/2025-07-17/streamlit-dataflow-experiment/image-1.png" class=""><p>也沒看到 HTML 有被重新請求，那合理懷疑是走 WebSocket 了。後來問了 ChatGPT 才確認是 WebSocket 搭配 Protobuf 的實作。</p><p>眼見為憑，自己還是要動手驗證看看。</p><h2 id="拿自己的-Streamlit-Side-Project-來實驗"><a href="#拿自己的-Streamlit-Side-Project-來實驗" class="headerlink" title="拿自己的 Streamlit Side Project 來實驗"></a>拿自己的 Streamlit Side Project 來實驗</h2><p>快速寫一個 Streamlit 元件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br>st.title(<span class="hljs-string">&quot;詐騙文案分析器&quot;</span>)<br><br>text = st.text_area(<span class="hljs-string">&quot;請貼上詐騙文案：&quot;</span>)<br><br><span class="hljs-keyword">if</span> st.button(<span class="hljs-string">&quot;分析詐騙文案&quot;</span>):<br>    <span class="hljs-keyword">if</span> text:<br>        st.write(text)<br>        st.write(<span class="hljs-string">&quot;分析中...&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;後端待分析的文案：<span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        st.warning(<span class="hljs-string">&quot;請先貼上詐騙文案！&quot;</span>)<br></code></pre></td></tr></table></figure><p>用 Streamlit 啟動：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ streamlit <span class="hljs-built_in">run</span> app.py<br></code></pre></td></tr></table></figure><p>可以立即得到一個精美的 Streamlit 網頁，同時打開 Dev Tool 觀測 WebSocket 的建立。</p><p>這邊可以看到有一個 HTTP 101 Upgrade 使用 WebSocket 的請求，代表瀏覽器已經和後端的伺服器建立了連線。</p><img src="/2025-07-17/streamlit-dataflow-experiment/image-3.png" class=""><p>接著我們試著輸入一段文字送給後端，並觀察 WebSocket 傳送的訊息，可以得到一個 base64 編碼的二進位檔案。</p><p>補充：後來才知道現在瀏覽器已經可以直接查看 WebSocket 的訊息了，以前都不知道。手上版本的 Firefox 沒辦法這樣查看，後來就改成用 Chrome 來實驗。</p><h2 id="Decode-Protobuf-訊息"><a href="#Decode-Protobuf-訊息" class="headerlink" title="Decode Protobuf 訊息"></a>Decode Protobuf 訊息</h2><p>去找了目前版本的 Streamlit 原始碼中定義的 schema，自己轉檔成 Python。因為對 Protobuf 不夠熟，試了很久都失敗。</p><p>最後直接把 base64 字串貼到線上工具 <a href="https://www.protobufpal.com/">protobufpal</a> 解出如下圖的 JSON 格式。</p><img src="/2025-07-17/streamlit-dataflow-experiment/image-4.png" class=""><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;subMesssage_11&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;subMesssage_1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subMesssage_2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;subMesssage_1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;string_1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$ID-b2e0ce08522d671c761a53ba564ac075-None&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;bytes_6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;0&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">72</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">105</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">32</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">230</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">136</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;5&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">145</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">230</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;7&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">152</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;8&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">175</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;9&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">32</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;10&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">74</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;11&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">111</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;12&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">101</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;13&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">32</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;14&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">232</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;15&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">128</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;16&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">129</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;17&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">229</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;18&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">184</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;19&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">171</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;20&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">229</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;21&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">149</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;22&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">166</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;23&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">239</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;24&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">188</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;25&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">140</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;26&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">230</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;27&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">156</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;28&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">128</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;29&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">232</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;30&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">191</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;31&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">145</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;32&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">233</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;33&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">129</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;34&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">142</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;35&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">231</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;36&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">154</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;37&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">132</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;38&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">229</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;39&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">165</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;40&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">189</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;41&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">229</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;42&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">151</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;43&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">142</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;44&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">239</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;45&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">188</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;46&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">159</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;string_3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3f41e546893dc64b71aaacad12cad815&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subMesssage_4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subMesssage_5&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subMesssage_8&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;string_1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Asia/Taipei&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;int_2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18446744073709551136</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;string_3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zh-TW&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;string_4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:8501/&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;int_5&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;string_6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dark&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>拿到這串二進位資料後，用 Python 轉回 UTF-8 字串：</p><img src="/2025-07-17/streamlit-dataflow-experiment/image-5.png" class=""><p>就得到當初我輸入進 Streamlit UI 的文字了！</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>本來是想快速建立一個 Streamlit 專案來體驗看看，順便體驗一下 Cursor 和 Uvicorn 等沒用過的開發工具，順手做了實驗驗證一下 ChatGPT 給的答案。</p><ul><li>Protobuf 的運作機制還不夠熟，也許以後可以自己實作玩一次。</li><li>了解到 WebSocket 搭配 Protobuf 具有幾個優點：<ol><li>瀏覽器和後端可以雙向溝通，透過 WebSocket 可以即時把資料送到後端。</li><li>可以從 Dev Tool 看到訊息的大小都是以 B 計算，非常輕量。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>技術筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devtools</tag>
      
      <tag>streamlit</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello from Kevin</title>
    <link href="/2025-07-16/hello-from-Kevin/"/>
    <url>/2025-07-16/hello-from-Kevin/</url>
    
    <content type="html"><![CDATA[<h1 id="Kevin-的第一篇文章"><a href="#Kevin-的第一篇文章" class="headerlink" title="Kevin 的第一篇文章"></a>Kevin 的第一篇文章</h1><p>一直想要有個自己的部落格來寫點<del>東西</del>廢文, 花了一點時間把 Hexo 和 Fluid theme 弄起來，很有成就感呀！</p><p>之後在陸續把其他平台上的文章慢慢搬過來</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>讀書心得 | 閱讀力：在碎片化時代建立高效輸入與輸出系統</title>
    <link href="/2023-03-01/reading-efficiency-system/"/>
    <url>/2023-03-01/reading-efficiency-system/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文最初發表於 2023 年，後搬遷至此歸檔。</p></blockquote><hr><p>標題乍看之下像是在讀哪本輕小說，一般人看到這種「工具書」可能連翻都不會翻。但這並不是一本工具書，更像是作者分享自己吸收資訊的「目的」與「心法」。</p><p>佐佐木俊尚是一位作家與新聞工作者。吸引我閱讀這本書的，除了書名外，也包括對媒體從業者如何面對海量資訊的好奇。本書介紹了各類新聞媒體與書籍的閱讀方法，並提出了「散漫力」的概念，用來提升生活與工作的效率。</p><blockquote><p>閱讀的主要目標，是為了得到多元觀點與知識，並將這些轉化為「知肉」。</p></blockquote><p>「知肉」是作者自創的詞，用來形容那些內化為自身、變成可用觀點與行動準則的知識。本書整體就是圍繞著如何生成知肉而展開。</p><img src="/2023-03-01/reading-efficiency-system/image-2.jpg" class=""><h2 id="媒體閱讀的心法：光譜與象限"><a href="#媒體閱讀的心法：光譜與象限" class="headerlink" title="媒體閱讀的心法：光譜與象限"></a>媒體閱讀的心法：光譜與象限</h2><p>作者提出媒體的兩種分類方式：</p><ol><li><p><strong>深度</strong>：</p><ul><li>平行媒體：資訊量多但內容淺</li><li>垂直媒體：主題聚焦、分析深入</li></ul></li><li><p><strong>立場</strong>：</p><ul><li>偏頗媒體：立場明確，觀點主觀</li><li>中立媒體：立場相對客觀，報導為主</li></ul></li></ol><p>將這兩種光譜畫成二維象限，會得到：</p><ul><li>平行媒體 — 中立</li><li>平行媒體 — 偏頗</li><li>垂直媒體 — 中立</li><li>垂直媒體 — 偏頗</li></ul><blockquote><p>方法：先從平行中立媒體取得輪廓 → 再從垂直中立媒體取得觀點 → 結合為新聞的全貌。</p></blockquote><h2 id="推式資訊-vs-拉式資訊"><a href="#推式資訊-vs-拉式資訊" class="headerlink" title="推式資訊 vs 拉式資訊"></a>推式資訊 vs 拉式資訊</h2><p>作者提醒，我們每天都在接收來自社群平台的「推式資訊」，這些資訊容易形成過濾泡泡，導致營養不良的「知肉」。</p><p>反之，應該學會主動出擊，建立自己的「拉式資訊」系統。作者的方法如下：</p><ol><li>使用 RSS 閱讀器訂閱優質來源</li><li>初步篩選後，將有興趣的文章儲存至 Instapaper&#x2F;Pocket</li><li>深度閱讀後，將內容與筆記整合進 Notion 等筆記系統</li></ol><p>這提醒我：我以往閱讀習慣是隨機看到就讀，閱讀過程中常中斷而導致遺忘。其實應該將「資訊收集」與「資訊吸收」拆分開來，在不同時間完成。</p><h2 id="散漫力與多工的活用"><a href="#散漫力與多工的活用" class="headerlink" title="散漫力與多工的活用"></a>散漫力與多工的活用</h2><p>作者主張：「不要強迫專注，而是學會活用散漫」。</p><p>與其勉強自己專注，不如認清我們很難長時間集中，將注意力有限的資源花在真正需要投入的任務上，其餘瑣事則安排在「散漫狀態」下完成。</p><p>這與電腦的 multitasking 不同。人腦不能像電腦隨時中斷、切換、重啟。我們應該依照任務的專注力需求分配如下：</p><blockquote><p>例如：輕 — 輕 — 重 — 輕 — 重</p></blockquote><p>這樣交錯安排能達成最好的輸出。</p><div style="width: 100%; display: flex; justify-content: center">  <div style="padding: 5px; width: 50%">    <img src="/2023-03-01/reading-efficiency-system/image-1.jpg" class="">  </div></div><h3 id="我的電子書閱讀筆記方式："><a href="#我的電子書閱讀筆記方式：" class="headerlink" title="我的電子書閱讀筆記方式："></a>我的電子書閱讀筆記方式：</h3><ul><li>使用 Kindle 做重點標註</li><li>使用手機&#x2F;電腦即時筆記到 Notion</li><li>將 clippings 檔上傳到 Clippings 或匯入 Notion 整理</li><li>最後將筆記轉化為自己的觀點文章（例如這篇）</li></ul><h3 id="我的後續行動："><a href="#我的後續行動：" class="headerlink" title="我的後續行動："></a>我的後續行動：</h3><ul><li>平衡「輸入」與「輸出」，以寫作檢驗是否真正獲得知肉</li><li>開始使用 RSS Reader 系統化閱讀流程</li><li>把家中說明書、資料電子化掃描進 NAS，減少紙本雜亂</li><li>更有效率地整合手邊工具（Instapaper、Notion）</li></ul><hr><p>這本書帶給我最大的啟發是：</p><blockquote><p>不在於專注力提升技巧，而是用「系統設計」去面對自己的分心本能，將之化為可用的能力。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>讀書心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知識管理</tag>
      
      <tag>閱讀力</tag>
      
      <tag>散漫力</tag>
      
      <tag>輸入與輸出</tag>
      
      <tag>媒體識讀</tag>
      
      <tag>RSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
